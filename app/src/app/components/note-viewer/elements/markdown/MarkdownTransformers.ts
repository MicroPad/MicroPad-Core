import { ShowdownExtension } from 'showdown';
import { substituteInlineFendExpressions } from 'fend-wasm-web';
import { START_FEND$ } from '../../../../services/FendService';
import { firstValueFrom } from 'rxjs';

export type MarkdownTransformer = ShowdownExtension;

interface FendResponseComponent {
	type: 'fend_output' | 'fend_error' | 'unprocessed';
	contents: string;
}

let HAS_STARTED_FEND: boolean = false;

export async function preTransform() {
	await firstValueFrom(START_FEND$);
	HAS_STARTED_FEND = true;
}

export const fendTransformer: MarkdownTransformer = {
	type: 'listener',
	listeners: {
		'hashHTMLBlocks.after': (evtName, text) => {
			if (!HAS_STARTED_FEND) throw new Error(`fend has not been started. Make sure preTransform() has ran before running other markdown transformers.`);

			// e.g. [[1+1]] -> 2
			const components: FendResponseComponent[] = JSON.parse(substituteInlineFendExpressions(text, 500));
			let result = '';
			for (const component of components) {
				switch (component.type) {
					case 'fend_output':
						result += `<span title="Generated by fend">${component.contents}</span>`;
						break;
					case 'fend_error':
						let errorMessage = component.contents;
						if (errorMessage === 'interrupted') {
							errorMessage = 'Calculation timed out';
						}
						result += `<span style="color: red"><i>Error: ${errorMessage}</i></span>`;
						break;
					default:
						result += component.contents;
				}
			}
			return result;
		}
	}
};

export const colourTransformer: MarkdownTransformer = {
	type: 'listener',
	listeners: {
		'images.after': (event, text: string) =>
			// e.g. c[this is green](green), or c[red](rgb(255, 0, 0))
			text.replace(/c\[([^\]]+)]\(([^()]*(?:\([^()]*\)[^()]*)?)\)/gi, (match, content, colour) =>
				`<span style="color: ${colour}">${content}</span>`
			)
	}
};

export const mathsTransformer: () => MarkdownTransformer[] = () => {
	let matches: string[] = [];
	return [
		{
			type: 'listener',
			listeners: {
				'hashHTMLBlocks.after': (evtName, text) => {
					let i = 0;
					return text.replaceAll(/(===[^]+?===|''[^]+?''|;;[^]+?;;|\$\$[^]+?\$\$|\$[^]+?\$)/gi, match => {
						matches.push(match);
						return '%MATHPLACEHOLDER' + i++ + 'ENDMATHPLACEHOLDER%';
					});
				}
			}
		},
		{
			type: 'output',
			filter: text => {
				for (let i = 0; i < matches.length; ++i) {
					const pat = '%MATHPLACEHOLDER' + i + 'ENDMATHPLACEHOLDER%';
					text = text.replace(new RegExp(pat, 'gi'), matches[i]);
				}

				matches = [];
				return text;
			}
		}
	]
}
